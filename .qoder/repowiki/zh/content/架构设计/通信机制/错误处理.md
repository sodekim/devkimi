# 错误处理

<cite>
**本文档引用的文件**  
- [error.rs](file://src-tauri/src/error.rs)
- [base64_text.rs](file://src-tauri/src/command/codec/base64_text.rs)
- [json_yaml.rs](file://src-tauri/src/command/codec/json_yaml.rs)
- [rsa.rs](file://src-tauri/src/command/crypto/rsa.rs)
- [regex.rs](file://src-tauri/src/command/text/regex.rs)
- [store.tsx](file://src/store.tsx)
- [Cargo.toml](file://src-tauri/Cargo.toml)
- [regex.ts](file://src/command/text/regex.ts)
- [regex.tsx](file://src/view/text/regex.tsx)
- [markdown.ts](file://src/command/text/markdown.ts)
- [markdown.tsx](file://src/view/text/markdown.tsx)
</cite>

## 目录
1. [简介](#简介)
2. [Rust端错误类型定义与实现](#rust端错误类型定义与实现)
3. [前端错误捕获与解析机制](#前端错误捕获与解析机制)
4. [错误码分类标准](#错误码分类标准)
5. [用户友好的错误消息展示方案](#用户友好的错误消息展示方案)
6. [全局错误通知机制](#全局错误通知机制)
7. [完整错误传播链示例](#完整错误传播链示例)
8. [日志记录与用户反馈最佳实践](#日志记录与用户反馈最佳实践)

## 简介
devkimi项目是一个基于Tauri框架的桌面应用，实现了前后端通信中的完整错误处理机制。本系统通过Rust端自定义Error类型（如CommandError）并利用thiserror库生成可序列化的错误信息，前端通过tauri::invoke调用后端命令，并使用try-catch机制捕获和解析异常。系统区分网络错误、命令执行错误和业务逻辑错误，结合store.tsx中的状态管理实现全局错误通知，为用户提供清晰的错误反馈。

## Rust端错误类型定义与实现

devkimi项目在Rust端通过`thiserror`库实现了结构化的错误处理机制。核心实现位于`src-tauri/src/error.rs`文件中，定义了两个关键宏：`serialize_error!`和`command_error!`。

`serialize_error!`宏为错误类型实现了`serde::Serialize` trait，确保错误可以被序列化传输到前端。`command_error!`宏则用于定义命令模块中的具体错误枚举类型，通过`#[derive(Debug, thiserror::Error)]`自动生成错误格式化实现。

各个命令模块（如codec、converter、crypto等）都定义了自己的错误类型。例如，在base64文本编解码中，定义了`Utf8`和`DecodeBase64`两种错误；在JSON/YAML转换中，定义了`Json`和`Yaml`错误；在RSA加密中，定义了`Rsa`、`Pkcs1`、`Pkcs8`等多种错误类型。

这些错误类型都遵循统一的模式：使用`command_error!`宏定义枚举，每个枚举变体通过`#[error(...)]`属性指定错误消息模板，并使用`#[from]`属性实现自动的错误类型转换。

**Section sources**
- [error.rs](file://src-tauri/src/error.rs#L1-L38)
- [base64_text.rs](file://src-tauri/src/command/codec/base64_text.rs#L1-L22)
- [json_yaml.rs](file://src-tauri/src/command/codec/json_yaml.rs#L1-L19)
- [rsa.rs](file://src-tauri/src/command/crypto/rsa.rs#L1-L78)

## 前端错误捕获与解析机制

前端通过`@tauri-apps/api/core`提供的`invoke`函数调用后端Rust命令。当后端返回错误时，`invoke`函数会抛出JavaScript异常，前端通过Promise的`.catch()`方法或async/await的try-catch语句捕获这些异常。

在`src/command/text/regex.ts`中，`parseRegex`函数调用`invoke`并返回Promise，调用方需要处理可能的错误：

```typescript
const parseRegex = async (
  text: string,
  pattern: string,
  global: boolean,
  multiLine: boolean,
  caseInsensitive: boolean,
) => {
  return invoke<Capture[]>("parse_regex", {
    text,
    pattern,
    global,
    multiLine,
    caseInsensitive,
  });
};
```

在视图组件中，如`src/view/text/regex.tsx`，通过`.catch()`捕获错误并进行处理：

```typescript
createEffect(() => {
  if (pattern().length > 0 && text().length > 0) {
    parseRegex(text(), pattern(), global(), multiLine(), caseInsensitive())
      .then(setCaptures)
      .catch((e) => console.error("parse regex error!", e));
  } else {
    setCaptures([]);
  }
});
```

类似的错误处理模式也出现在`src/view/text/markdown.tsx`中，用于处理Markdown解析错误。

**Section sources**
- [regex.ts](file://src/command/text/regex.ts#L1-L27)
- [regex.tsx](file://src/view/text/regex.tsx#L1-L203)
- [markdown.ts](file://src/command/text/markdown.ts#L1-L7)
- [markdown.tsx](file://src/view/text/markdown.tsx#L1-L60)

## 错误码分类标准

devkimi项目的错误码采用分层分类标准，主要分为以下几类：

1. **编解码错误**：处理文本、图像等数据编解码过程中的错误
   - `Utf8`: UTF-8编码/解码错误
   - `DecodeBase64`: Base64解码错误

2. **数据格式转换错误**：处理不同数据格式间转换的错误
   - `Json`: JSON解析或序列化错误
   - `Yaml`: YAML解析或序列化错误

3. **加密解密错误**：处理加密算法相关的错误
   - `Rsa`: RSA算法错误
   - `Pkcs1`: PKCS#1格式错误
   - `Pkcs8`: PKCS#8格式错误
   - `Spki`: SPKI格式错误

4. **正则表达式错误**：处理正则表达式相关的错误
   - `Regex`: 正则表达式语法错误

5. **通用错误**：跨领域的通用错误类型
   - `Base64Decode`: Base64解码错误
   - `Utf8`: UTF-8处理错误

每种错误类型都有明确的错误消息模板，如"utf-8 error: {0}"、"decode base64 error: {0}"等，其中{0}会被具体的错误描述替换。

**Section sources**
- [base64_text.rs](file://src-tauri/src/command/codec/base64_text.rs#L18-L21)
- [json_yaml.rs](file://src-tauri/src/command/codec/json_yaml.rs#L15-L18)
- [rsa.rs](file://src-tauri/src/command/crypto/rsa.rs#L70-L77)
- [regex.rs](file://src-tauri/src/command/text/regex.rs#L5-L9)

## 用户友好的错误消息展示方案

devkimi项目通过以下方式实现用户友好的错误消息展示：

1. **错误消息本地化**：虽然当前错误消息为英文，但系统设计支持通过错误类型映射到本地化消息。

2. **上下文相关错误处理**：在不同功能模块中，根据具体上下文展示相关错误。例如在正则表达式测试中，错误会直接显示在预览区域。

3. **错误信息降级显示**：在`src/view/text/markdown.tsx`中，当Markdown解析出错时，错误信息会直接显示在预览区域：
   ```typescript
   .catch((e) => setHtml(e.toString()))
   ```

4. **控制台日志记录**：所有未处理的错误都会通过`console.error`记录，便于开发者调试。

5. **错误边界处理**：通过try-catch机制防止错误导致应用崩溃，确保应用的稳定性。

系统通过将技术性错误信息转化为用户可理解的反馈，提升了用户体验。

**Section sources**
- [markdown.tsx](file://src/view/text/markdown.tsx#L1-L60)
- [regex.tsx](file://src/view/text/regex.tsx#L1-L203)

## 全局错误通知机制

devkimi项目通过`store.tsx`中的状态管理机制实现全局错误通知。虽然当前实现主要依赖组件级别的错误处理，但系统架构支持全局错误通知。

`store.tsx`文件定义了应用的全局状态管理，使用Solid.js的`createStore`创建响应式状态，并通过`StoreContext`提供上下文。虽然当前主要管理主题和编辑器设置，但可以扩展以包含错误状态。

```typescript
export const StoreProvider = (props: { children?: JSX.Element }) => {
  const [settings, setSettings] = createStore<Settings>(defaultSettings);
  let store: Store | null = null;

  // 初始化
  onMount(async () => {
    store = await load("store.json");
    setSettings((await store.get<Settings>("settings")) || defaultSettings);
  });

  // 设置发生变动时保存设置信息
  createEffect(() => {
    trackStore(settings);
    if (store) {
      store
        .set("settings", settings)
        .then(() => store!.save())
        .then(() => console.debug("Settings saved successfully!"))
        .catch((e) => console.error("Settings save failed:", e));
    }
  });
  // ...省略其余代码
};
```

可以通过扩展`Settings`类型或添加新的状态字段来实现全局错误状态管理，将错误信息存储在全局状态中，并在UI的适当位置显示。

**Section sources**
- [store.tsx](file://src/store.tsx#L1-L88)

## 完整错误传播链示例

以下是从后端错误到前端捕获的完整传播链示例：

1. **后端Rust代码**（`src-tauri/src/command/codec/base64_text.rs`）：
   ```rust
   #[tauri::command]
   pub fn decode_text_base64(base64: &str, mode: Base64Mode) -> Result<String, Error> {
       let bytes = mode.decode(base64)?;  // 可能返回DecodeBase64错误
       String::from_utf8(bytes).map_err(Into::into)  // 可能返回Utf8错误
   }
   ```

2. **前端调用代码**（`src/command/text/regex.ts`）：
   ```typescript
   const parseRegex = async (text: string, pattern: string, ...) => {
     return invoke<Capture[]>("parse_regex", { text, pattern, ... });
   };
   ```

3. **前端组件处理**（`src/view/text/regex.tsx`）：
   ```typescript
   createEffect(() => {
     parseRegex(text(), pattern(), ...)
       .then(setCaptures)
       .catch((e) => console.error("parse regex error!", e));
   });
   ```

当后端`decode_text_base64`函数执行失败时，Rust的`?`操作符会将错误传播到函数返回值。Tauri框架自动将`Error`类型序列化并通过IPC传递给前端。前端的`invoke`函数接收到错误响应后，拒绝返回的Promise，触发`.catch()`中的错误处理逻辑。

**Section sources**
- [base64_text.rs](file://src-tauri/src/command/codec/base64_text.rs#L12-L16)
- [regex.ts](file://src/command/text/regex.ts#L1-L27)
- [regex.tsx](file://src/view/text/regex.tsx#L62-L67)

## 日志记录与用户反馈最佳实践

devkimi项目在错误处理方面体现了以下最佳实践：

1. **结构化错误定义**：使用`thiserror`库创建结构化的错误类型，便于错误分类和处理。

2. **自动错误转换**：通过`#[from]`属性实现自动的错误类型转换，简化错误处理代码。

3. **可序列化错误**：通过`serialize_error!`宏确保所有错误都可以被序列化，支持跨语言通信。

4. **细粒度错误分类**：为不同功能模块定义具体的错误类型，便于精确处理。

5. **前端错误隔离**：在组件级别捕获和处理错误，防止错误影响整个应用。

6. **开发期日志记录**：使用`console.error`记录错误，便于开发调试。

7. **用户反馈降级**：当发生错误时，提供有意义的降级体验，如显示原始错误信息而非空白界面。

8. **状态持久化错误处理**：在`store.tsx`中，对设置保存操作的错误进行捕获和记录，确保应用状态的一致性。

这些实践共同构成了一个健壮的错误处理系统，既保证了开发效率，又提供了良好的用户体验。

**Section sources**
- [error.rs](file://src-tauri/src/error.rs#L1-L38)
- [store.tsx](file://src/store.tsx#L58-L63)
- [Cargo.toml](file://src-tauri/Cargo.toml#L1-L69)