# 后端实现

<cite>
**本文档中引用的文件**  
- [lib.rs](file://src-tauri/src/lib.rs)
- [Cargo.toml](file://src-tauri/Cargo.toml)
- [error.rs](file://src-tauri/src/error.rs)
- [mod.rs](file://src-tauri/src/command/mod.rs)
- [fs.rs](file://src-tauri/src/command/fs.rs)
- [font.rs](file://src-tauri/src/command/font.rs)
- [hash.rs](file://src-tauri/src/command/generator/hash.rs)
- [base64_text.rs](file://src-tauri/src/command/codec/base64_text.rs)
- [json_yaml.rs](file://src-tauri/src/command/converter/json_yaml.rs)
- [rsa.rs](file://src-tauri/src/command/crypto/rsa.rs)
- [jsonpath.rs](file://src-tauri/src/command/text/jsonpath.rs)
</cite>

## 目录

1. [简介](#简介)
2. [模块结构设计与创建](#模块结构设计与创建)
3. [依赖引入与Cargo.toml配置](#依赖引入与cargotoml配置)
4. [业务逻辑实现与错误处理](#业务逻辑实现与错误处理)
5. [命令导出与前端调用](#命令导出与前端调用)
6. [单元测试与集成测试](#单元测试与集成测试)
7. [总结](#总结)

## 简介

`devkimi` 是一个基于 Tauri 框架构建的桌面应用程序，其后端使用 Rust 实现。本项目通过模块化设计将各类功能（如编解码、加密、格式化等）组织在 `src-tauri/src/command/` 目录下。本文档详细说明如何在该项目中实现新的后端功能，涵盖从模块创建、依赖管理、逻辑实现到测试的完整流程。

**本节不分析具体源码文件，因此无来源标注。**

## 模块结构设计与创建

在 `devkimi` 项目中，所有后端命令均位于 `src-tauri/src/command/` 目录下，并按功能划分为多个子模块，如 `codec`、`converter`、`crypto` 等。每个子模块对应一个功能类别，并包含多个 `.rs` 文件实现具体功能。

要创建一个新的 Rust 模块，首先应在 `src-tauri/src/command/` 下创建一个新目录（例如 `my_feature`），并在其中创建功能实现文件（如 `operation.rs`）。随后，在该目录下创建 `mod.rs` 文件以声明模块内容。例如：

```rust
// src-tauri/src/command/my_feature/mod.rs
pub mod operation;
```

最后，在根级 `src-tauri/src/command/mod.rs` 中添加对该新模块的公开声明：

```rust
pub mod my_feature; // 新增行
```

此结构确保了模块的层级清晰且可被外部访问。

**模块结构设计与创建**
- [mod.rs](file://src-tauri/src/command/mod.rs#L1-L8)

## 依赖引入与Cargo.toml配置

`devkimi` 项目的依赖由 `src-tauri/Cargo.toml` 文件管理。当新功能需要第三方库时，必须在此文件的 `[dependencies]` 部分添加相应条目。

例如，若新模块需进行 JSON 处理，则应确保已包含 `serde_json`；若涉及哈希计算，则需引入 `sha2`、`md-5` 等库。添加方式如下：

```toml
[dependencies]
serde_json = { version = "1.0", features = ["preserve_order"] }
sha2 = "0.10"
md-5 = "0.10"
```

Rust 的包管理器 Cargo 会在构建时自动下载并链接这些依赖。此外，对于某些库的特定功能（如 UUID 生成支持 v4），还需启用对应 `features`。

所有现有模块均已正确配置所需依赖，开发者只需根据新功能需求参照已有模式添加即可。

**依赖引入与Cargo.toml配置**
- [Cargo.toml](file://src-tauri/Cargo.toml#L20-L58)

## 业务逻辑实现与错误处理

每个命令模块实现具体的业务逻辑，并通过 `#[tauri::command]` 宏暴露为可被前端调用的函数。函数通常接受基本类型参数（如 `&str`、`bool`、枚举等），返回 `Result<T, Error>` 类型以支持错误传播。

以 `generator/hash.rs` 中的文本哈希生成功能为例：

```rust
#[tauri::command]
pub fn generate_text_hash(text: &str, algorithm: Algorithm, uppercase: bool) -> String {
    digest(text.as_bytes(), algorithm, uppercase)
}
```

该函数调用内部 `digest` 函数完成实际计算，并根据算法枚举选择不同的哈希实现（MD5、SHA1、SHA256 等）。

### 错误处理机制

项目统一使用 `command_error!` 宏定义模块级错误类型。该宏基于 `thiserror` 和自定义 `serialize_error` 宏，使错误可序列化并传递至前端。例如，在 `fs.rs` 中定义：

```rust
command_error! {
    (Io, "io error: {0}", #[from] std::io::Error),
    (InvalidFileName, "invalid file name: {0}", String),
}
```

这会生成一个 `Error` 枚举类型，自动实现 `std::error::Error` 和 `Serialize`，便于前端捕获和展示错误信息。

**业务逻辑实现与错误处理**
- [hash.rs](file://src-tauri/src/command/generator/hash.rs#L1-L52)
- [fs.rs](file://src-tauri/src/command/fs.rs#L9-L33)
- [error.rs](file://src-tauri/src/error.rs#L1-L31)

## 命令导出与前端调用

为了让前端能够调用后端 Rust 函数，必须在 `src-tauri/src/lib.rs` 的 `tauri::generate_handler!` 宏中注册该命令。

该宏接收一系列命令函数路径，Tauri 在运行时将其暴露为 JavaScript 可调用接口。例如，已注册的命令包括：

```rust
invoke_handler(tauri::generate_handler![
    command::fs::open_file,
    command::fs::copy_file,
    command::formatter::json::format_json,
    // ... 其他命令
    command::crypto::rsa::generate_rsa_key_pair,
])
```

新增命令需在此列表中添加其完整路径，格式为 `command::模块名::子模块::函数名`。注册后，前端可通过 `invoke('command_name')` 调用（命令名由函数名自动转换为 snake_case）。

例如，Rust 中定义的 `generate_rsa_key_pair` 函数，在前端可通过：

```ts
invoke('generate_rsa_key_pair', { key_format: 'Pkcs8', bit_size: 2048 })
```

进行调用。

**命令导出与前端调用**
- [lib.rs](file://src-tauri/src/lib.rs#L11-L43)

## 单元测试与集成测试

`devkimi` 项目鼓励为关键功能编写单元测试，以确保逻辑正确性和稳定性。测试代码通常嵌入在模块内部的 `#[cfg(test)] mod test` 块中。

例如，在 `font.rs` 中包含一个测试用例验证字体获取功能：

```rust
#[cfg(test)]
mod test {
    use crate::command::font::get_system_fonts;

    #[test]
    fn test_get_system_fonts() {
        let fonts = get_system_fonts().unwrap();
        println!("{:?}", fonts);
    }
}
```

此类测试可通过 `cargo test` 命令运行，Cargo 会自动编译并执行所有标记为 `#[test]` 的函数。

对于涉及文件系统、加密或网络的操作，建议同时编写集成测试，放置于 `tests/` 目录下，以模拟真实调用场景。

**单元测试与集成测试**
- [font.rs](file://src-tauri/src/command/font.rs#L19-L28)
- [jsonpath.rs](file://src-tauri/src/command/text/jsonpath.rs#L1-L19)

## 总结

在 `devkimi` 项目中实现后端功能的完整流程如下：

1. 在 `src-tauri/src/command/` 下创建模块目录并实现 `.rs` 文件；
2. 在模块目录中创建 `mod.rs` 导出子模块；
3. 在根级 `mod.rs` 中声明新模块为 `pub mod xxx`；
4. 在 `Cargo.toml` 中添加所需依赖；
5. 使用 `#[tauri::command]` 编写具体业务逻辑函数；
6. 利用 `command_error!` 宏定义模块错误类型；
7. 在 `lib.rs` 的 `generate_handler!` 中注册新命令；
8. 编写单元测试验证功能正确性；
9. 前端通过 `invoke` 调用对应命令。

该流程保证了代码结构清晰、可维护性强，并充分利用了 Tauri 框架的安全性和跨平台能力。

**本节为总结性内容，未分析具体源码文件，因此无来源标注。**